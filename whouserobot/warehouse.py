from abc import ABCMeta, abstractmethod

import matplotlib.pyplot as plt
import numpy as np

from whouserobot import Dir


class WareHouseBase(metaclass=ABCMeta):
    """
    This abstract class represents a warehouse. A warehouse has many tiles in a
    rectangular fashion. Each tile has a i, j index. Neighboring tiles can be
    connected or disconnected if there is a wall between them. To store the
    relations between the tiles the class has the self.s attribute which is an
    abbriviation for states. This is an NxN matrix, where N = width * height.
    Various patterns can be generated by subclassing this clsas and overriding
    the generate method and setting the states matrix. Be aware that the
    resulting matrix has to be symmetric, otherwise the robot can't go freely
    between connected tiles, only in 1 direction.
    """

    def __init__(self, width: int, height: int):
        """
        Initialize the warehouse with it's dimensions.

        :param width: The width of the warehouse
        :param type: int

        :param height: The height of the warehouse.
        :param type: int
        """
        self._w = width
        self._h = height
        self._N = self._w * self._h
        self.s = [[0 for _ in range(self._N)] for _ in range(self._N)]

    @abstractmethod
    def generate(self):
        """
        This funcitons generates various patterns in a warehouse by placing
        walls between tiles. To place a wall between tile i,j and k,l simply
        use the self[i, j, k, l] = 0 or update the state matrix yourself.
        In any case the resulting state matrix have to be symmetric and also
        placing connection between tiles that far from each other can result
        that the robot will teleport between tiles. To check your state matrix
        use the validate_states method.
        """
        ...

    def render(self):
        """
        Print the warehouse using matplotlib. The function returns the ax object to further modifications and plots.

        :return: ax
        """
        # create the figure
        fig, ax = plt.subplots()

        # cell width and cell height
        cw = 1
        ch = 1

        # draw the blue boundary lines
        ax.plot([-cw / 2, -cw / 2 + self._w], [-ch / 2, -ch / 2], "b-", lw=2, zorder=10)
        ax.plot([-cw / 2, -cw / 2 + self._w], [-ch / 2 + self._h, -ch / 2 + self._h], "b-", lw=2, zorder=10)
        ax.plot([-cw / 2, -cw / 2], [-ch / 2, -ch / 2 + self._h], "b-", lw=2, zorder=10)
        ax.plot([-cw / 2 + self._w, -cw / 2 + self._w], [-ch / 2, -ch / 2 + self._h], "b-", lw=2, zorder=10)

        for j in range(self._h):
            for i in range(self._w):
                n0 = i + j * self._w
                ax.text(i, j, n0, horizontalalignment="center", verticalalignment="center")

                def drawline(x0, y0, x1, y1):
                    ax.plot([x0, x1], [y0, y1], "k-", lw=2)

                # right wall
                if not self[i, j, i + 1, j]:
                    drawline(i + cw / 2, j - ch / 2, i + cw / 2, j + ch / 2)

                # left wall
                if not self[i, j, i - 1, j]:
                    drawline(i - cw / 2, j - ch / 2, i - cw / 2, j + ch / 2)

                # ceiling wall
                if not self[i, j, i, j + 1]:
                    drawline(i - cw / 2, j + ch / 2, i + cw / 2, j + ch / 2)

                # floor wall
                if not self[i, j, i, j - 1]:
                    drawline(i - cw / 2, j - ch / 2, i + cw / 2, j - ch / 2)

        ax.axis("equal")
        ax.set_xticks(range(self._w))
        ax.set_yticks(range(self._h))
        return ax

    def validate_states(self):
        """
        Check if a state matrix is valid. Should be symmetric and only
        neighbouring tiles can be connected. Also the robot should be able to
        travel from any tile to any other tile, therefore no isolated tile
        can exist.
        """
        # TODO: fill this
        return True

    def coord2state(self, i: int, j: int):
        # TODO: check for i,j inrange
        return i + j * self._w

    def state2coord(self, si: int):
        assert si > -1
        assert si < self._N
        row = si % self._w
        col = (si - row) // self._w
        return row, col

    def check_coord(self, i: int, j: int):
        inrangex = lambda x: (x > -1) and (x < self._w)
        inrangey = lambda y: (y > -1) and (y < self._h)

        return inrangex(i) and inrangey(j)

    def __getitem__(self, idx):
        """
        Check if cell (i,j) and (k,l) are connected.
        If they are connected return 1 else 0.

        i: xi
        j: yi

        k: xj
        l: yj
        """
        i, j, k, l = idx

        if self.check_coord(i, j) and self.check_coord(k, l):
            row = self.coord2state(i, j)
            col = self.coord2state(k, l)
            return self.s[row][col]
        else:
            return 0

    def __setitem__(self, idx, value: int):
        """ """
        # TODO: fill this
        assert value in (0, 1), "State can only be 0 or 1. Got {value=} instead."
        value = int(value)

        i, j, k, l = idx

        if self.check_coord(i, j) and self.check_coord(k, l):
            row = self.coord2state(i, j)
            col = self.coord2state(k, l)
            self.s[row][col] = value


class ExampleWarehouse(WareHouseBase):
    def __init__(self):
        super().__init__(4, 3)

    def generate(self):
        self.s = [
            [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
            [1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0],
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0],
            [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
        ]


class RandomWareHouse(WareHouseBase):
    """
    This is a random layout generator, it will certainly generate a layout that
    is not fully connected.
    """

    def generate(self):
        """
        Generate a random symmetric matrix.
        """
        self.s = np.random.choice([0, 1], p=(0.12, 0.88), size=(self._N, self._N))
        self.s = (self.s + self.s.T) // 2


if __name__ == "__main__":
    w = ExampleWarehouse()
    ax = w.render()
    plt.savefig(Dir.MEDIA / "example_warehouse.png", dpi=450)
